---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

```

```{python}
labeled_path = "../data/labels.parquet"
```

```{python}
labeled_df = pd.read_parquet(labeled_path)
print(labeled_df.shape)
labeled_df.head()
```

```{python}
predicted_df = pd.read_parquet('../data/output/xgb.parquet')
predicted_df.tail()
```

```{python}
actual_predicted_df = labeled_df.copy()
actual_predicted_df['Predicted_demand'] = predicted_df['Predicted_demand']
actual_predicted_df.isna().sum()
actual_predicted_df = actual_predicted_df.dropna()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Data General information
<!-- #endregion -->

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Finding Important Locations
<!-- #endregion -->

```{python}
def plot_cumsum_demand(labeled_df, target_demand):
    grouped_df = labeled_df.groupby('Location')['Demand'].sum().reset_index().sort_values(by='Demand', ascending=False).reset_index()
    cumulative_demand = (grouped_df['Demand'].cumsum() / grouped_df['Demand'].sum()).to_numpy()

    plt.plot(range(1,263), cumulative_demand)
    plt.xlabel('Location numbers')
    plt.ylabel('Cumulative Demand')
    plt.title('Cumulative Demand by Location')
    target_x = (cumulative_demand <= target_demand).argmin()
    plt.axhline(y=target_demand, color='r', linestyle='--', label=f'Target Demand ({target_demand})')
    plt.axvline(x=target_x, color='g', linestyle='--', label=f'Target Location ({target_x})')

    plt.legend() 
    plt.show()
    important_locations = grouped_df.iloc[:target_x, grouped_df.columns.get_loc('Location')]
    important_locations = important_locations.to_numpy()
    return important_locations
```

```{python}
important_locations = plot_cumsum_demand(labeled_df, 0.97)
```

```{python}
important_locations
```

```{python}
high_demand_locations_df = actual_predicted_df\
                                    .loc[actual_predicted_df['Location'].isin(important_locations)]\
                                        .reset_index(drop=True)
high_demand_locations_df
```

```{python}
low_demand_locations_df = actual_predicted_df\
                                    .loc[~actual_predicted_df['Location'].isin(important_locations)]\
                                        .reset_index(drop=True)
low_demand_locations_df
```

```{python}
def calculate_mape(actual_predicted_df:pd.DataFrame):
    
    actual_predicted_df['error'] = (np.abs(actual_predicted_df['Demand']-
                                            actual_predicted_df['Predicted_demand']))*100

    error_per_location = (actual_predicted_df
                                .groupby('Location')
                                .mean())[['Demand', 'Predicted_demand', 'error']]
    error_per_date = (actual_predicted_df
                                .groupby('Date')
                                .mean())[['Demand', 'Predicted_demand', 'error']]
                     
    actual_predicted_df['day_of_week'] = actual_predicted_df['Date'].dt.dayofweek
    error_per_dayofweek = (actual_predicted_df
                                .groupby('day_of_week')
                                .mean())[['Demand', 'Predicted_demand', 'error']]

    return error_per_location, error_per_date, error_per_dayofweek

```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
plot mape
<!-- #endregion -->

```{python}

def plot_mape(errors: pd.DataFrame, per):
    errors = errors
    fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(16,5))
    errors.plot(y='error', ax=axes, color='red', kind='line', marker='o')
    
    thresholds = pd.DataFrame({'min':[errors['error'].min()], 
                               'mean':[errors['error'].mean()], 
                               'max':[errors['error'].max()]})
    for i, thre in enumerate(thresholds):
            threshold = pd.DataFrame(index=errors.index)
            threshold[str(thresholds.columns[i])] = [thresholds[thre][0]]*len(errors)
            threshold.plot(ax=axes, kind='line', label=str(thre), linestyle='--')
        
    plt.xlabel(str(per))
    title = 'Model Error per ' + str(per) + ' using method ' + str(per)
    plt.title(title)

    plt.show()
```

```{python}
error_per_location, error_per_date, error_per_dayofweek = calculate_mape(high_demand_locations_df)
```

```{python}
error_per_location.shape
```

```{python}
plot_mape(error_per_location, 'Date')

```

```{python}

```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Low Demand Locations Report
<!-- #endregion -->

```{python}
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
```

```{python}
def accuracy_per_location(actual_predicted_df: pd.DataFrame):
    # threshold_demand = {}
    num_loc = actual_predicted_df['Location'].unique()
    per_rec_location = pd.DataFrame(columns=['Location','Date', 'Demand', 'Predicted_demand', 'actual_class','predict_class'])
    for loc in num_loc:
        loc_df = actual_predicted_df.loc[actual_predicted_df['Location']==loc]
        loc_mean_demand = loc_df['Demand'].mean()
        loc_df['actual_class'] = loc_df['Demand']-loc_mean_demand
        loc_df['predict_class'] = loc_df['Predicted_demand']-loc_mean_demand
        per_rec_location = pd.concat([per_rec_location,loc_df])
            
    y_test = np.where(per_rec_location['actual_class']>0,1,0)
    y_pred = np.where(per_rec_location['predict_class']>0,1,0)
    conf_matrix = confusion_matrix(y_true=y_test, y_pred=y_pred)
    # 
    # Print the confusion matrix using Matplotlib
    #
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.matshow(conf_matrix, cmap=plt.cm.Oranges, alpha=0.3)
    for i in range(conf_matrix.shape[0]):
        for j in range(conf_matrix.shape[1]):
            ax.text(x=j, y=i,s=conf_matrix[i, j], va='center', ha='center', size='xx-large')
    percision = precision_score(y_test, y_pred)
    recall = recall_score(y_test, y_pred)
    
    plt.xlabel('Predictions', fontsize=18)
    plt.ylabel('Actuals', fontsize=18)
    title = 'Confusion Matrix for low demand locations: \n Precision: '+f'{percision:.2f}'+' Recall: '+f'{recall:.2f}'
    plt.title(title, fontsize=18)
    plt.show()
    
    return per_rec_location
    
```

```{python}
acc_loc_df = accuracy_per_location(low_demand_locations_df)
```

```{python}
acc_loc_df.head()
```

```{python}

```

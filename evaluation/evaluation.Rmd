---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Imports
<!-- #endregion -->

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Config
<!-- #endregion -->

```{python}
labeled_path = "../data/labels.parquet"
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Loading Dataset
<!-- #endregion -->

```{python}
dataset = pd.read_parquet(labeled_path)
print(dataset.shape)
dataset.head()
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluation
<!-- #endregion -->

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Generate temporary predicted Data
<!-- #endregion -->

```{python}
def generate_temporary_prediction(dataset):
    predicted_demand = dataset.Demand.shift(1)
    dataset = dataset[1:]
    predicted_data = pd.DataFrame(dataset[['Location', 'Date']])
    predicted_data['Demand'] = predicted_demand
    return predicted_data

```

```{python}
predicted_data = generate_temporary_prediction(dataset)
predicted_data = predicted_data.dropna()
print(predicted_data.shape)
predicted_data.head()
```

```{python}
actual_data = dataset[1:]
print(actual_data.shape)
actual_data.head()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
calculate loss functions
<!-- #endregion -->

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_loss_mape(actual_data, predicted_data, fix_inf = 1):
    losses_df = actual_data[['Location','Date']].copy()
    losses_df['actual_demand'] = actual_data.Demand
    losses_df['predicted_demand'] = predicted_data.Demand
    losses_df = losses_df.dropna()

    fix_inf_val = np.where(losses_df['actual_demand']==0, fix_inf, losses_df['actual_demand'])
    losses_df['error'] = ((np.abs(losses_df['actual_demand']-losses_df['predicted_demand']))/
                          (fix_inf_val))*100

    loss_per_location = (losses_df.groupby('Location')
                                        .agg({'actual_demand':'mean', 
                                            'predicted_demand':'mean', 
                                            'error':'mean'}))
    loss_per_date = (losses_df.groupby('Date')
                                    .agg({'actual_demand':'mean', 
                                        'predicted_demand':'mean', 
                                        'error':'mean'}))

    losses_df['day_of_week'] = losses_df['Date'].dt.dayofweek
    loss_per_dayofweek = (losses_df.groupby('day_of_week')
                                        .agg({'actual_demand':'mean', 
                                            'predicted_demand':'mean', 
                                            'error':'mean'}))

    return loss_per_location, loss_per_date, loss_per_dayofweek

```

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_loss_rmse(actual_data, predicted_data):
    losses_df = actual_data[['Location','Date']].copy()
    losses_df['actual_demand'] = actual_data.Demand
    losses_df['predicted_demand'] = predicted_data.Demand
    losses_df = losses_df.dropna()

    losses_df['error'] = np.square(np.subtract(losses_df['actual_demand'],losses_df['predicted_demand']))

    loss_per_location = np.sqrt(losses_df.groupby('Location')
                                .agg({'actual_demand':'mean', 
                                      'predicted_demand':'mean', 
                                      'error':'mean'}))
    
    loss_per_date = np.sqrt(losses_df.groupby('Date')
                            .agg({'actual_demand':'mean', 
                                'predicted_demand':'mean', 
                                'error':'mean'}))
    
    losses_df['day_of_week'] = losses_df['Date'].dt.dayofweek
    loss_per_dayofweek = np.sqrt(losses_df.groupby('day_of_week')
                                 .agg({'actual_demand':'mean', 
                                      'predicted_demand':'mean', 
                                      'error':'mean'}))

    return loss_per_location, loss_per_date, loss_per_dayofweek

```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Plot accuracies function
<!-- #endregion -->

```{python}
# %matplotlib inline
def plot_acc(losses: pd.DataFrame, label, method, min_threshold, mean_threshold):
    error_df = losses.reset_index()
    fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(16,5))

    ind_name = error_df.columns[0]
    
    plot_error_df = error_df[[ind_name,'error']].copy()
    plot_demand_df = error_df[[ind_name,'predicted_demand']].copy()

    min_threshold_line_df = pd.DataFrame(min_threshold,
                                          index=plot_error_df[ind_name], 
                                          columns=['min_error']).reset_index()
    mean_threshold_line_df = pd.DataFrame(mean_threshold, 
                                          index=plot_error_df[ind_name], 
                                          columns=['mean_error']).reset_index()
    
    plot_error_df.plot(x=ind_name, y='error', ax=axes, color='red', kind='line')
    min_threshold_line_df.plot(x=ind_name, y='min_error', ax=axes, color='yellow', kind='line')
    mean_threshold_line_df.plot(x=ind_name, y='mean_error', ax=axes, color='blue', kind='line')
    
    if method == 'rmse':
        plot_demand_df.plot(x=ind_name, y='predicted_demand', ax=axes, color='green', kind='line')
    
    plt.legend(['error','min_error','mean_error','predicted_demand'])
    plt.xlabel(str(label))
    title = 'Model Error per ' + str(label) + ' using method ' + str(method)
    plt.title(title)

    plt.show()
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluate Model function
<!-- #endregion -->

```{python}
def prepare_report(losses: pd.DataFrame, plot_label, method, error_limit):
    min_threshold = losses.min()['error']
    max_threshold = losses.max()['error']
    mean_threshold = losses.mean()['error']

    report_dict = {
            'best_accuracy': min_threshold,
            'best_accuracy_point': [losses['error'].idxmin()],
            'worst_accuracy': max_threshold,
            'worst_accuracy_point': [losses['error'].idxmax()],
            'mean_accuracy': mean_threshold
        }
    
    if error_limit>0 :
        losses['error'] = (np.where(losses['error']>error_limit, error_limit, losses['error']))
    
    plot_acc(losses, plot_label, method, min_threshold, mean_threshold)

    return report_dict
```

```{python}
def evaluate_model(dataset, predicted_data, method, error_limit):
    if method == 'mape':
        loss_per_location, loss_per_date, loss_per_dayofweek = calculate_loss_mape(dataset, predicted_data)
    elif method == 'rmse':
        loss_per_location, loss_per_date, loss_per_dayofweek = calculate_loss_rmse(dataset, predicted_data)
    else:
        return "bad method request"
    
    date_report_df = pd.DataFrame(prepare_report(loss_per_date, 'date', method, error_limit))
    loc_report_df = pd.DataFrame(prepare_report(loss_per_location, 'location', method, error_limit))
    dayofweek_report_df = pd.DataFrame(prepare_report(loss_per_dayofweek, 'day of the week', method, error_limit))
    
    return(date_report_df, loc_report_df, dayofweek_report_df)
```

```{python}
date_report_df, loc_report_df, dayofweek_report_df = evaluate_model(actual_data, predicted_data, 'mape', 200)
```

```{python}
print('mape per date')
date_report_df.head()
```

```{python}
print("mape per location")
loc_report_df.head()
```

```{python}
print("mape per day of the week")
dayofweek_report_df.head()
```

```{python}
date_rmse_report_df, loc_rmse_report_df, dow_rmse_report_df = evaluate_model(actual_data, predicted_data, 'rmse', 0)
```

```{python}
print('rmse per date')
date_rmse_report_df.head()
```

```{python}
print("rmse per location")
loc_rmse_report_df.head()
```

```{python}
print("rmse per day of the week")
dow_rmse_report_df.head()
```

plot actual VS predicted

```{python}
def percentage(actual_predicted_df, location_id, percent):
  actual = actual_predicted_df[actual_predicted_df['Location']==location_id]['actual_demand'].to_numpy()
  pred = actual_predicted_df[actual_predicted_df['Location']==location_id]['predicted_demand'].to_numpy()
  count = 0
  for i in range(len(actual)):
   if actual[i]*(1-percent)<=pred[i]<=actual[i]*(1+percent):
      count = count + 1
  percentage_data = count/len(actual)
  return round(percentage_data,2)*100
```

```{python}
def predicted_vs_actual(actual_predicted_df, location_ids, percent):
    plt.figure(figsize=(16,5))

    # error_percentage = pd.DataFrame(columns=['Location', 'precentage'])
    for loc in location_ids:
        error_percentage = percentage(actual_predicted_df, loc, percent)
        label = 'location ' + str(loc) +' percentage is ' + str(error_percentage)
        plt.scatter(actual_predicted_df[actual_predicted_df['Location']==loc]['actual_demand'], 
                    actual_predicted_df[actual_predicted_df['Location']==loc]['predicted_demand'], 
                    s=50, alpha=0.7,
                    label = label)
    
    title = 'the percentage of prediction in ' + str(percent) + ' error range'
    plt.title(title)
    plt.xlabel('Actual demand', fontsize = 14)
    plt.ylabel('Predicted demand', fontsize = 14)
    plt.legend()
    
    max_demand_value = actual_predicted_df.loc[actual_predicted_df['Location']
                                               .isin(location_ids)]['actual_demand'].max()
    plot_range = max_demand_value + 0.3*max_demand_value
    
    plt.xlim(0, plot_range)
    plt.ylim(0, plot_range)
    
    plt.plot((0,plot_range),(0,plot_range), color='black', lw=0.7)
    plt.plot((0,plot_range),(0,plot_range*(1+percent)), ls="--", color='black', lw=0.8)
    plt.plot((0,plot_range),(0,plot_range*(1-percent)), ls="--", color='black', lw=0.8)

    plt.show()
```

```{python}
def plot_actual_vs_predict_per_location(actual_predicted_df: pd.DataFrame, loc_per_plot=10, percent=0.2):
    demand_per_location_sorted = (actual_predicted_df.groupby('Location')
                                    .agg({'actual_demand':'mean', 
                                        'predicted_demand':'mean'})).sort_values(
                                                                        by='actual_demand', 
                                                                        ascending=False)
    
    location_num = len(demand_per_location_sorted)
    for i in range(0, location_num, loc_per_plot):
        plot_locations = demand_per_location_sorted[i:i+loc_per_plot].reset_index()['Location']
        predicted_vs_actual(actual_predicted_df, plot_locations, percent)

        
```

```{python}
percent = 0.2
loc_per_plot = 10
actual_predicted_df = actual_data[['Location','Date']].copy()
actual_predicted_df['actual_demand'] = actual_data.Demand
actual_predicted_df['predicted_demand'] = predicted_data.Demand
plot_actual_vs_predict_per_location(actual_predicted_df, loc_per_plot, percent)
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
plot actual and predicted demand
<!-- #endregion -->

```{python}
# %matplotlib inline
def plot_actual_predicted(actual_predicted_df, loc_per_plot = 10):

    demand_per_location = (actual_predicted_df.groupby('Location')
                                .agg({'actual_demand':'mean', 
                                      'predicted_demand':'mean'}))
    
    location_num = len(demand_per_location)
    for i in range(0, location_num, loc_per_plot):
        
        plot_locations = demand_per_location[i:i+loc_per_plot].reset_index()  
        plot_df = actual_predicted_df[actual_predicted_df['Location'].isin(plot_locations['Location'])] 
        test_plot_df = plot_df.groupby(['Location'])
        
        fig, ax = plt.subplots(1,1,figsize=(16,7))
        for l in plot_locations['Location']:
            label = ['loc:'+str(l)+' actual', 'loc:'+str(l)+' predicted']
            loc_plot_df = test_plot_df.get_group(l)
            loc,_ = ax.plot(loc_plot_df['Date'],
                    loc_plot_df[['actual_demand','predicted_demand']],
                    label=label)
            
        title = ('actual demand and predicted demand in locations ' + 
                    str(i) + ' to ' + str(i+loc_per_plot-1) + ' in dates')
        plt.title(title)
        plt.xlabel('Date', fontsize = 14)
        plt.ylabel('Demand', fontsize = 14)
        plt.legend()
        plt.show()
        
```

```{python}
actual_predicted_df = actual_data[['Location','Date']].copy()
actual_predicted_df['actual_demand'] = actual_data.Demand
actual_predicted_df['predicted_demand'] = predicted_data.Demand
plot_actual_predicted(actual_predicted_df)
```

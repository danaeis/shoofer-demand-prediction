---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

#Imports

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
```

#Config

```{python}
# Add your input path
labeled_path = "../data/labels.parquet"
```

#Loading Dataset

```{python}
dataset = pd.read_parquet(labeled_path)
dataset.head()
```

#Generate temporary predicted Data

```{python}
def create_sample_prediction(dataset):
    predicted_demand = dataset.Demand.shift(1)
    predicted_data = pd.DataFrame(dataset[['Location', 'Date']])
    predicted_data['Demand'] = predicted_demand
    return predicted_data

```

```{python}
predicted_data = create_sample_prediction(dataset)
predicted_data = predicted_data.dropna()
predicted_data.head()
```

##calculate accuracy functions

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_accuracy_mape(actual_data, predicted_data, fix_inf_val = 1000):
    locations = pd.DataFrame(actual_data['Location'].unique(), columns=['Location'])
    loc_accuracies = pd.DataFrame(columns=['Location', 'accuracy_mape'])
    # iterate over location to calculate mape for each
    for loc_id in locations['Location']:
        actual_demand, predicted_demand = actual_data.loc[actual_data['Location']==loc_id].Demand, predicted_data.loc[predicted_data['Location']==loc_id].Demand
        error = (np.abs(actual_demand-predicted_demand)+fix_inf_val)/(actual_demand+fix_inf_val)
        error *= 100
        mape = pd.DataFrame({"Location": [loc_id], "accuracy_mape": [np.sum(error)/len(error)]})
        loc_accuracies = pd.concat([loc_accuracies,mape])
    return loc_accuracies

```

```{python}
accuracies = calculate_accuracy_mape(dataset, predicted_data).set_index('Location')
print(accuracies)

```

##Plot accuracies function

```{python}
def plot_acc_per_loc(accuracies):
    # plt.figure(figsize=(180, 6))
    ax = accuracies.plot.bar(x='Location', y='accuracy_mape', rot=0)
    plt.xlabel('Locations')
    plt.ylabel('Accuracy(mape)')
    plt.title('Model Accuracy per Location')
    plt.legend()
    plt.show()

```

##Evaluate Model function

```{python}
def evaluate_model(data, predicted_data):
    accuracy = calculate_accuracy_mape(data, predicted_data)
    plot_acc_per_loc(accuracy)
    accuracy = accuracy.set_index('Location')
    report = {
        'best_accuracy': [accuracy['accuracy_mape'].min()],
        'best_accuracy_location': [accuracy['accuracy_mape'].idxmin()],
        'worst_accuracy': [accuracy['accuracy_mape'].max()],
        'worst_accuracy_location': [accuracy['accuracy_mape'].idxmax()],
        'mean_accuracy': [accuracy['accuracy_mape'].mean()]
    }
    return(pd.DataFrame(report))
    
```

```{python}
evaluate_model(dataset, predicted_data)
```

```{python}

```

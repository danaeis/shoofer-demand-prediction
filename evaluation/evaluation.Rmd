---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Imports
<!-- #endregion -->

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Config
<!-- #endregion -->

```{python}
labeled_path = "../data/labels.parquet"
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Loading Dataset
<!-- #endregion -->

```{python}
dataset = pd.read_parquet(labeled_path)
dataset.head()
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluation
<!-- #endregion -->

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Generate temporary predicted Data
<!-- #endregion -->

```{python}
def generate_temporary_prediction(dataset):
    predicted_demand = dataset.Demand.shift(1)
    predicted_data = pd.DataFrame(dataset[['Location', 'Date']])
    predicted_data['Demand'] = predicted_demand
    return predicted_data

```

```{python}
predicted_data = generate_temporary_prediction(dataset)
predicted_data = predicted_data.dropna()
predicted_data.head()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
calculate loss functions
<!-- #endregion -->

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_loss_mape(actual_data, predicted_data, fix_inf = 1):
    losses_df = actual_data[['Location','Date']].copy()
    losses_df['actual_demand'] = actual_data.Demand
    losses_df['predicted_demand'] = predicted_data.Demand
    losses_df = losses_df.dropna()

    fix_inf_val = np.where(losses_df['actual_demand']==0, fix_inf, losses_df['actual_demand'])    
    losses_df['error'] = ((np.abs(losses_df['actual_demand']-losses_df['predicted_demand']))/
                          (losses_df['actual_demand']+fix_inf_val))*100

    loss_per_location = losses_df.groupby('Location').agg({'error':'mean'})
    loss_per_date = losses_df.groupby('Date').agg({'error':'mean'})
    return loss_per_location, loss_per_date

```

```{python}
loss_per_location, loss_per_date = calculate_loss_mape(dataset, predicted_data)
loss_per_location.head()
```

```{python}
loss_per_date.head()
```

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_loss_rmse(actual_data, predicted_data):
    losses_df = actual_data[['Location','Date']].copy()
    losses_df['actual_demand'] = actual_data.Demand
    losses_df['predicted_demand'] = predicted_data.Demand
    losses_df = losses_df.dropna()

    losses_df['error'] = np.square(np.subtract(losses_df['actual_demand'],losses_df['predicted_demand']))

    loss_per_location = np.sqrt(losses_df.groupby('Location').agg({'error':'mean'}))
    loss_per_date = np.sqrt(losses_df.groupby('Date').agg({'error':'mean'}))

    return loss_per_location, loss_per_date

```

```{python}
rmse_loss_per_location, rmse_loss_per_date = calculate_loss_rmse(dataset, predicted_data)
rmse_loss_per_location.head()
```

```{python}
rmse_loss_per_date.head()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Plot accuracies function
<!-- #endregion -->

```{python}
def plot_acc(losses: pd.DataFrame, label, method, min_threshold, mean_threshold):
    ax = losses.plot.bar(rot=0)
    plt.xlabel(str(label))
    ylabel = 'Loss: ' + method
    plt.ylabel(ylabel)
    title = 'Model Accuracy per '+ str(label)
    plt.legend("error")
    plt.title(title)

    plt.show()

```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluate Model function
<!-- #endregion -->

```{python}
def prepare_report(losses: pd.DataFrame, plot_label, method, error_limit):
    min_threshold = losses.min()['error']
    max_threshold = losses.max()['error']
    mean_threshold = losses.mean()['error']

    report_dict = {
            'best_accuracy': min_threshold,
            'best_accuracy_point': [losses['error'].idxmin()],
            'worst_accuracy': max_threshold,
            'worst_accuracy_point': [losses['error'].idxmax()],
            'mean_accuracy': mean_threshold
        }
    
    if error_limit>0 :
        losses = pd.DataFrame(np.where(losses>error_limit, error_limit, losses))
    plot_acc(losses, plot_label, method, min_threshold, mean_threshold)

    return report_dict
```

```{python}
def evaluate_model(dataset, predicted_data, method, error_limit):
    if method == 'mape':
        loss_per_location, loss_per_date = calculate_loss_mape(dataset, predicted_data)
    elif method == 'rmse':
        loss_per_location, loss_per_date = calculate_loss_rmse(dataset, predicted_data)
    date_report_df = pd.DataFrame(prepare_report(loss_per_date, 'date', method, error_limit))
    loc_report_df = pd.DataFrame(prepare_report(loss_per_location, 'location', method, error_limit))
    return(date_report_df, loc_report_df)
```

```{python}
date_report_df, loc_report_df = evaluate_model(dataset, predicted_data, 'mape', 100)
```

```{python}
print('mape per date')
date_report_df.head()
```

```{python}
print("mape per location")
loc_report_df.head()
```

```{python}
date_rmse_report_df, loc_rmse_report_df = evaluate_model(dataset, predicted_data, 'rmse', 0)
```

```{python}
print('rmse per date')
date_rmse_report_df.head()
```

```{python}
print("rmse per location")
loc_rmse_report_df.head()
```

```{python}

```

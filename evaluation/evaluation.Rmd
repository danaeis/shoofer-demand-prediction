---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Imports
<!-- #endregion -->

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Config
<!-- #endregion -->

```{python}
labeled_path = "../data/labels.parquet"
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Loading Dataset
<!-- #endregion -->

```{python}
dataset = pd.read_parquet(labeled_path)
dataset.head()
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluation
<!-- #endregion -->

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Generate temporary predicted Data
<!-- #endregion -->

```{python}
def generate_temporary_prediction(dataset):
    predicted_demand = dataset.Demand.shift(1)
    predicted_data = pd.DataFrame(dataset[['Location', 'Date']])
    predicted_data['Demand'] = predicted_demand
    return predicted_data

```

```{python}
predicted_data = generate_temporary_prediction(dataset)
predicted_data = predicted_data.dropna()
predicted_data.head()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
calculate loss functions
<!-- #endregion -->

```{python}
# fix_inf_val will add to numerator and denumerator to prevent having the inf value
def calculate_loss_mape(actual_data, predicted_data, fix_inf = 1):
    losses_df = actual_data[['Location','Date']].copy()
    losses_df['actual_demand'] = actual_data.Demand
    losses_df['predicted_demand'] = predicted_data.Demand
    losses_df = losses_df.dropna()

    fix_inf_val = np.where(losses_df['actual_demand']==0, fix_inf, losses_df['actual_demand'])    
    losses_df['error'] = ((np.abs(losses_df['actual_demand']-losses_df['predicted_demand']))/
                          (losses_df['actual_demand']+fix_inf_val))*100

    loss_per_location = losses_df.groupby('Location').agg({'error':'mean'})
    loss_per_date = losses_df.groupby('Date').agg({'error':'mean'})
    return loss_per_location, loss_per_date

```

```{python}
loss_per_location, loss_per_date = calculate_loss_mape(dataset, predicted_data)
loss_per_location.head()
```

```{python}
loss_per_date.head()
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Plot accuracies function
<!-- #endregion -->

```{python}
def plot_acc(losses: pd.DataFrame, label):
    ax = losses.plot.bar(rot=0)
    plt.xlabel(str(label))
    plt.ylabel('Loss(mape)')
    title = 'Model Accuracy per '+ str(label)
    plt.legend("error")
    plt.title(title)
    plt.show()

```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Evaluate Model function
<!-- #endregion -->

```{python}
def prepare_report(losses: pd.DataFrame, plot_label):
    min_threshold = losses.min()['error']
    max_threshold = losses.max()['error']
    mean_threshold = losses.mean()['error']

    report_dict = {
            'best_accuracy': min_threshold,
            'best_accuracy_point': [losses['error'].idxmin()],
            'worst_accuracy': max_threshold,
            'worst_accuracy_point': [losses['error'].idxmax()],
            'mean_accuracy': mean_threshold
        }
    losses = pd.DataFrame(np.where(losses>120, 120, losses))
    plot_acc(losses, plot_label)

    return report_dict
```

```{python}
def evaluate_model(dataset, predicted_data):
    loss_per_location, loss_per_date = calculate_loss_mape(dataset, predicted_data)
    date_report_df = pd.DataFrame(prepare_report(loss_per_date, 'date'))
    loc_report_df = pd.DataFrame(prepare_report(loss_per_location, 'location'))
    return(date_report_df, loc_report_df)
    
```

```{python}
date_report_df, loc_report_df = evaluate_model(dataset, predicted_data)
```

```{python}
print("date\n",date_report_df,"\nlocation\n", loc_report_df)
```

---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

<!-- #region id="KzcJPH0e1BE6" -->
# imports
<!-- #endregion -->

```{python colab={'base_uri': 'https://localhost:8080/'}, id="kEr9J20VzxOq", outputId="b88a69f2-0a15-4bfc-a660-a7a3bf9ad751"}
from math import sqrt
from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error, mean_absolute_error
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from prophet import Prophet
import logging
import multiprocessing
```

```{python}
logging.getLogger("prophet").setLevel(logging.ERROR)
logging.getLogger("cmdstanpy").setLevel(logging.ERROR)
```

<!-- #region id="uEOhGFuj2J3p" -->
# loading Dataset
<!-- #endregion -->

```{python}
INPUT_PATH = '/Users/maedeh/Desktop/demand_project/shoofer-demand-prediction/data/labels.parquet'
OUTPUT_PATH = '/Users/maedeh/Desktop/demand_project/shoofer-demand-prediction/data/prophet_predict.parquet'
```

```{python id="xLg8mI4Yr8Zc"}
def load_data(path):
    dataset = pd.read_parquet(path, engine = 'pyarrow') 
    return dataset
```

```{python}
rides_df = load_data(INPUT_PATH)
rides_df.head()
```

# aggregating_labels 

```{python}
def aggregating_labels(rides_df):
    location_labels_df = pd.pivot_table(rides_df, values ='Demand', index =['Date'], columns =['Location'])
    prefix = 'Location_'
    location_labels_df = location_labels_df.add_prefix(prefix)
    location_labels_df = location_labels_df.reset_index().rename_axis('index')
    return location_labels_df
```

```{python}
location_labels_df = aggregating_labels(rides_df)
print(f'location_labels_df shape : {location_labels_df.shape}')
location_labels_df.head()
```

<!-- #region id="7fgxL33c7yRz" -->
# Prophet MODEL
<!-- #endregion -->

<!-- #region id="Ty2gmgJ3Yuig" -->
## train 
<!-- #endregion -->

```{python}
train_size_ratio = 0.12
```

```{python id="QWWSsvJwVWaR"}
def split_data(location_labels_df, location, train_size_ratio):
    train_end_date = int(len(location_labels_df) * train_size_ratio)
    train_data = location_labels_df.loc[:train_end_date,['Date',location]]
    test_data = location_labels_df.loc[train_end_date:, ['Date',location]]
    train_data.columns = ['ds','y']
    test_data.columns = ['ds','y']
    return (train_data, test_data)
```

```{python id="jbk1N0pkxIPy"}
def prophet_forecast(train_data, test_data):
    history = train_data
    predictions = []
    for t in range(len(test_data)):
        model = Prophet()
        model.fit(history)
        ds = model.make_future_dataframe(periods=1)
        output = model.predict(ds)
        predictions.append(int(output.yhat.iloc[-1]))
        obs = test_data.iloc[[t],:]
        history = pd.concat([history, obs], axis = 0).reset_index(drop=True)

    return (test_data.y, predictions)

```

<!-- #region id="SllaVhLm3UCg" -->
### train and predict for all locationIDs

<!-- #endregion -->

```{python}
def predict_all_location(location_labels_df, train_size_ratio):
    
    predict_date_location = {}
    test_date_location = {}
    column = location_labels_df.columns
    
    for loc in column[1:]:
        
        train_data, test_data = split_data (location_labels_df, loc, train_size_ratio)
        result = prophet_forecast(train_data, test_data)
        test_date_location[loc] = result[0]
        predict_date_location[loc] = result[1]
    
        
    test_date_location = pd.DataFrame(test_date_location).reset_index(drop=True)
    predict_date_location = pd.DataFrame(predict_date_location).reset_index(drop=True)
    return (test_date_location, predict_date_location)
```

```{python}
test_date_location, predict_date_location = predict_all_location(location_labels_df, train_size_ratio)
```

<!-- #region id="t9TmKfCS3Fpx" -->
## evaluation
<!-- #endregion -->

```{python id="gD4cUUg1rlUd"}
def mape(test_data, predictions):
  mape = mean_absolute_percentage_error(test_data, predictions)
  return mape
```

```{python id="SqRKbhM_rgY8"}
def rmse(test_data, predictions):
  rmse = sqrt(mean_squared_error(test_data, predictions))
  return rmse
```

```{python}
def mape_rmse_all_location(test_date_location,predict_date_location):
    mape_error = {col: mape(test_date_location[col],predict_date_location[col]) for col in test_date_location.columns}
    rmse_error = {col: rmse(test_date_location[col],predict_date_location[col]) for col in test_date_location.columns}
    all_loc_mape = pd.DataFrame.from_dict(mape_error, orient='index')
    all_loc_rmse = pd.DataFrame.from_dict(rmse_error, orient='index')
    return (all_loc_mape, all_loc_rmse)
```

```{python}
all_loc_mape, all_loc_rmse = mape_rmse_all_location(test_date_location,predict_date_location)
```

### plots

```{python}
def plot_high_demand_error(all_loc_rmse,all_loc_mape):
    plt.rcParams['figure.figsize'] = (50, 30)
    index_high_demand = location_labels_df.iloc[:,1:].sum().sort_values(ascending=False).index[:51]
    
    plt.subplot(2,1,1)
    plt.plot(range(1,52), all_loc_rmse.loc[index_high_demand], linewidth=6)
    plt.title('RMSE of High Demand LocationID', fontsize=45)
    plt.ylabel('rmse', fontsize=35)
    plt.xlabel('LocationID', fontsize=35)
    plt.xticks(range(1,52), list(index_high_demand), rotation=45)
    plt.tick_params(axis='both', labelsize=25)
    
    
    plt.subplot(2,1,2)
    plt.plot(range(1,52), all_loc_mape.loc[index_high_demand], color='orange', linewidth=6)
    plt.title('MAPE of High Demand LocationID', fontsize=45)
    plt.ylabel('mape', fontsize=35)
    plt.xlabel('LocationID', fontsize=35)
    plt.xticks(range(1,52), list(index_high_demand), rotation=45)
    plt.tick_params(axis='both', labelsize=25)
    plt.tight_layout()
    
    plt.show()
```

```{python}
plot_high_demand_error(all_loc_rmse, all_loc_mape)
```

```{python}
def evaluation(test_date_location, predict_date_location):
    index_high_demand = location_labels_df.iloc[:,1:].sum().sort_values(ascending=False).index[:51]
    predict_data_vec = predict_date_location[index_high_demand].to_numpy().reshape((1,-1))
    test_data_vec = test_date_location[index_high_demand].to_numpy().reshape((1,-1))
    mape_error = mape(test_data_vec,predict_data_vec)
    rmse_error = rmse(test_data_vec,predict_data_vec)
    print(f'mape of high demand locations: {mape_error}')
    print(f'rmse of high demand locations: {rmse_error}')
```

```{python}
evaluation(test_date_location, predict_date_location)
```

# Save file

```{python}
def reshape_output(rides_df, predicted_date_location):
    dataset = rides_df.sort_values(['Date','Location'])[14*262:].reset_index(drop = True)
    dataset['prophet_predicted_demand'] = predicted_date_location.to_numpy().reshape((-1,1))
    dataset.drop(columns = ['Demand'], inplace = True)
    output_dataset = dataset.sort_values(['Location','Date']).reset_index(drop = True)
    return output_dataset
```

```{python}
predicted_data = reshape_output(rides_df, predict_date_location)
print(f'predicted data shape: {predicted_data.shape}')
predicted_data.head()
```

```{python}
def save_val_predicted(dataset, path):
    labels_df = dataset.to_parquet(path, index=False)
```

```{python}
save_val_predicted(predicted_data, OUTPUT_PATH)
```

```{python}

```

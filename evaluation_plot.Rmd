---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: demandenv
    language: python
    name: python3
---

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Imports
<!-- #endregion -->

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

<!-- #region notebookRunGroups={"groupValue": "2"} -->
Config
<!-- #endregion -->

```{python}
labeled_path = 'data/labels.parquet'
predicted_values_path = 'data/predictions.parquet'
```

<!-- #region notebookRunGroups={"groupValue": "1"} -->
Loading Dataset
<!-- #endregion -->

```{python}
prediction_df = pd.read_parquet(predicted_values_path)
print(prediction_df.shape)
prediction_df.head()
```

```{python}
dataset = pd.read_parquet(labeled_path)
train_df = dataset[dataset['Date'] < '2023-04-01']
test_df = dataset[dataset['Date'] >= '2023-04-01'].reset_index(drop=True)
print(test_df.shape)
test_df.head()
```

```{python}
prediction_df['Location'] = test_df['Location']
print(prediction_df.shape)
prediction_df.head()
```

```{python}
def predicted_vs_actual(axs, actual_value, predicted_value, location_id, percent):
    axs.scatter(actual_value[actual_value['Location']==location_id]['Demand'], predicted_value[predicted_value['Location']==location_id]['Demand'], s=50, c='b', edgecolors='k', alpha=0.7)
    axs.set_xlabel('Actual value', fontsize = 14)
    axs.set_ylabel('Predicted value', fontsize = 14)
    
    max_demand_value = actual_value[actual_value['Location']==location_id]['Demand'].max()
    plot_range = max_demand_value + 0.3*max_demand_value
    
    axs.set_xlim(0, plot_range)
    axs.set_ylim(0, plot_range)
    
    axs.plot((0,plot_range),(0,plot_range), color='black', lw=0.7)
    axs.plot((0,plot_range),(0,plot_range*(1+percent)), ls="--", color='black', lw=0.8)
    axs.plot((0,plot_range),(0,plot_range*(1-percent)), ls="--", color='black', lw=0.8)

```

```{python}
def percentage(actual_value, predicted_value, location_id, percent):
  actual = actual_value[actual_value['Location']==location_id]['Demand'].to_numpy()
  pred = predicted_value[predicted_value['Location']==location_id]['Demand'].to_numpy()
  count = 0
  for i in range(len(actual)):
   if actual[i]*(1-percent)<=pred[i]<=actual[i]*(1+percent):
      count = count + 1
  percentage_data = count/len(actual)
  return round(percentage_data,2)*100
```

```{python}
# Finding useful location ids
location_ids = test_df[test_df['Demand'] >= test_df['Demand'].mean()]['Location'].unique()
len(location_ids)
```

```{python}
num_rows = int(np.ceil(len(location_ids) / 7))
fig, axs = plt.subplots(num_rows, 7, figsize=(num_rows * 7, num_rows * 7))
percent = 0.2

for i, ax in enumerate(axs.flat):
    try:
        ax.set_title(f'Location {location_ids[i]} with {str(percentage(test_df, prediction_df, location_ids[i], percent))} probability')
        predicted_vs_actual(ax, test_df, prediction_df, location_ids[i], percent)
    except IndexError:
        pass
plt.show()
```

---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.7
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="8UTIGpTZZlOO" -->
# Imports
<!-- #endregion -->

```{python id="AnwSHO1L97I5"}
import datetime
from itertools import product
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.linear_model import Ridge
from sklearn.model_selection import GridSearchCV
import xgboost as xgb
import shap
```

<!-- #region id="pSSMa3G2wGmF" -->
# Configs
<!-- #endregion -->

<!-- #region id="MxbN2VgHwGmG" -->
## Constant Values
<!-- #endregion -->

```{python id="zIkDLK9zwGmG"}
INPUT_PATH = 'shoofer-demand-prediction/ML/datasets/'

START_DATE = '2023-01-01'
END_DATE = '2023-04-30'

feature_list = ['prev_month_demand', 'prev_2week_demand', 'prev_week_demand', 'prev_day_demand', 'month', 'day_month', 'day_week']

test_size_ratio = 0.5
```

<!-- #region id="5eS5BQE9wGmK" -->
# Data preparation

<!-- #endregion -->

<!-- #region id="TWsjXbpaznc_" -->
## Load Data
<!-- #endregion -->

```{python id="HAyNjqxNwGmH"}
def load_data(path, start_date: str, end_date: str):
    df = pd.read_parquet(path)
    start_date = datetime.date.fromisoformat(start_date)
    end_date = datetime.date.fromisoformat(end_date)
    filtered_df = df[(df['tpep_pickup_datetime'].dt.date >= start_date) &
                     (df['tpep_pickup_datetime'].dt.date <= end_date)]
    dataset = filtered_df.filter(items=['tpep_pickup_datetime', 'PULocationID'])
    dataset['PU_date'] = pd.to_datetime(dataset['tpep_pickup_datetime'].dt.date)
    return dataset
```

```{python id="87BFHUu1-z73"}
rides_df = load_data(INPUT_PATH, START_DATE, END_DATE)
```

```{python id="hCN-11QT3bp1"}
print(f'rides dataframe shape : {rides_df.shape}')
rides_df.head()
```

<!-- #region id="X2ES_CY6-fb5" -->
## Labeling
<!-- #endregion -->

```{python id="a7mNMQ-zwGmH"}
def labeling(dataset):
    dataset_labels = (
        dataset
        .groupby(['PULocationID', 'PU_date'])['PU_date']
        .count()
        .to_frame('Demand')
        .sort_values(['PULocationID', 'PU_date'], ascending=[True, True])
        .reset_index()
        .rename(columns={'PULocationID': 'Location', 'PU_date': 'Date'})
    )

    locations = pd.DataFrame(dataset_labels['Location'].unique(), columns=['Location'])
    dates = pd.DataFrame(dataset_labels['Date'].unique(), columns=['Date'])

    location_date_df = (
        locations
        .merge(dates, how='cross')
        .sort_values(['Location', 'Date'], ascending=[True, True])
        .reset_index(drop=True)
    )

    labels_df = (
        location_date_df
        .merge(dataset_labels, how='left', on=['Location', 'Date'])
        .fillna(value=0)
    )

    return labels_df

```

```{python id="VVRLakW_LeGp"}
labeled_df = labeling(rides_df)
```

```{python id="0Gm5j5em28Xy"}
print(f'labeled dataframe shape : {labeled_df.shape}')
labeled_df.head()
```

<!-- #region id="G0W2pR-70JJb" -->
## Add Feature
<!-- #endregion -->

```{python id="ifvk6uWS6hnT"}
def add_features(data):  # run after merging datasets and modifing date
    # Lag features
    data['prev_day_demand'] = data.groupby(['Location'])['Demand'].shift(1)
    data['prev_week_demand'] = data.groupby(['Location'])['Demand'].shift(7)
    data['prev_2week_demand'] = data.groupby(['Location'])['Demand'].shift(14)
    data['prev_month_demand'] = data.groupby(['Location'])['Demand'].shift(28)

    data = data.dropna()

    return data
```

```{python id="12zNfv8YwGmK"}
features_df = add_features(labeled_df)
```

```{python id="bJxWEkiD3VOZ"}
print(f'features dataframe shape : {features_df.shape}')
features_df.head()
```

<!-- #region id="7gXEv3Lm0ro0" -->
## Extract Calendar features
<!-- #endregion -->

```{python id="ZXCqsW6swGmI"}
def add_calendar_features(data):  # Year/Month/Day
    data['month'] = data['Date'].dt.month
    data['day_month'] = data['Date'].dt.day
    data['day_week'] = data['Date'].dt.dayofweek

    data['day_year'] = 0
    start_date = data['Date'].min()

    for index, row in data.iterrows():

        curr_date = row['Date']
        day_number = (curr_date - start_date).days

        data.at[index, 'day_year'] = day_number
    return data
```

```{python id="8pGrqumFwGmK"}
date_features_df = add_calendar_features(features_df)
```

```{python id="nh6jS7qG3MiV"}
print(f'date_features dataframe shape : {date_features_df.shape}')
date_features_df.head()
```

<!-- #region id="zN0kp6jw03DP" -->
## Split Train and Test Data
<!-- #endregion -->

```{python id="CMY1G1lmwGmI"}
def train_test_splitting(dataset, test_size):
    start_date = dataset['Date'].min()
    end_date = dataset['Date'].max()
    all_days = end_date - start_date

    train_df = dataset[(dataset['Date'] - start_date) < (1 - test_size) * all_days]
    test_df = dataset[(dataset['Date'] - start_date) >= (1 - test_size) * all_days]

    return train_df, test_df
```

```{python id="3xH4VMGNwGmK"}
train_df, test_df = train_test_splitting(date_features_df, test_size_ratio)
```

```{python id="xxGdRZfqwGmL"}
print(f'train dataframe shape : {train_df.shape}')
train_df.head()
```

```{python id="uPbINwH224Hy"}
print(f'test dataframe shape : {test_df.shape}')
test_df.head()
```

<!-- #region id="xf8ChW_7wGmL" -->
# Model Training
<!-- #endregion -->

<!-- #region id="mIhvw9lH92sa" -->
## **Gradient Boosting Regressor**
<!-- #endregion -->

<!-- #region id="13gFIyYfZyxh" -->
### Model Tuning
<!-- #endregion -->

```{python id="sOMPo5ryBm8g"}
def grid_search(model, test_parameters, train_data, feature_list, cv = None):
    gs = GridSearchCV(estimator = model, param_grid = test_parameters, scoring = 'neg_root_mean_squared_error', cv = cv, n_jobs = -1)
    gs.fit(train_data[feature_list], train_data['Demand'])
    return gs.best_params_, gs.best_score_
```

```{python id="cm3YTQCMZVvu", outputId="4cf0ed3b-0243-476a-af87-35db760c9e5c"}
param_test = {'max_depth':range(2,10,2), 'min_child_weight':range(1,6,2)}

params = {"objective": "reg:squarederror", "tree_method": "gpu_hist", 'n_estimators':140, 'learning_rate':0.1, 'max_depth':5,
         'min_child_weight':1, 'gamma':0, 'subsample':0.8, 'colsample_bytree':0.8, 'seed':27}

best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test,
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

```{python id="f42LBpS81NB5", outputId="10c38a48-2453-478d-b9c3-ef14f69d0a97"}
params.update(best_params)
param_test = {'gamma':[i/10.0 for i in range(0,5)]}
best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test, 
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

```{python id="Q3ueVbP51NB5", outputId="0559917d-9449-4877-e73a-19ee91f272ae"}
params.update(best_params)
param_test = {'subsample':[i/10.0 for i in range(6,10)], 'colsample_bytree':[i/10.0 for i in range(6,10)]}
best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test, 
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

```{python id="NKP1ofzt1NB5", outputId="019ff031-de3a-4b8d-f5ee-c1fd408300fd"}
params.update(best_params)
param_test = {'reg_alpha':[1e-5, 1e-2, 0.1, 1, 100]}
best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test, 
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

```{python id="mqXEz5h31NB6", outputId="a608106f-c416-4486-f047-1c0b29e00895"}
params.update(best_params)
param_test = {'n_estimators':list(range(1000, 5001, 500)), 'learning_rate':[0.01]}
best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test, 
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

```{python id="fnIfCrYW1NB6", outputId="e3fdc3c1-3bd1-48ae-8ad5-c621ee1bc7c2"}
params.update(best_params)
param_test = {'n_estimators':list(range(15000, 20001, 500)), 'learning_rate':[0.001]}
best_params, best_score = grid_search(model = xgb.XGBRegressor(**params), test_parameters = param_test, 
                                      train_data = train_df, feature_list = feature_list, cv = 5)
print(best_params, best_score)
```

<!-- #region id="H0IHB8t41NB6" -->
### Prediction
<!-- #endregion -->

```{python id="pbhM5Oe6PjW7"}
def model_predict(model, train_data, test_data, feature_list):

    model.fit(train_data[feature_list], train_data['Demand'])
    
    train_predict_df  = model.predict(train_data[feature_list])
    test_predict_df  = model.predict(test_data[feature_list])

    return train_predict_df, test_predict_df
```

```{python id="5AdQtdSqN7m9"}
params = {'learning_rate': 0.001, 'n_estimators': 15000, 'reg_alpha': 1, 'colsample_bytree': 0.6,
          'subsample': 0.9, 'gamma': 0.0, 'max_depth': 2, 'min_child_weight': 5}
model = xgb.XGBRegressor(**params)
yhat_train, yhat_test = model_predict(model, train_df, test_df, feature_list)
```

<!-- #region id="J0EYl9KtTfo7" -->
### Visualization
<!-- #endregion -->

```{python id="ao6nw8xsRvB9"}
def prediction_visualization(train_data, test_data, yhat_train, yhat_test):

    predicted_train_df = train_data
    predicted_test_df = test_data
    predicted_train_df['Predicted'] = yhat_train
    predicted_test_df['Predicted'] = yhat_test

    train_data = train_data.groupby('day_year')['Demand'].sum()
    test_data = test_data.groupby('day_year')['Demand'].sum()
    predicted_train_df = predicted_train_df.groupby('day_year')['Predicted'].sum()
    predicted_test_df = predicted_test_df.groupby('day_year')['Predicted'].sum()

    plt.title('Train')
    plt.plot(train_data)
    plt.plot(predicted_train_df)
    plt.legend(["Real Value", "Predicted"], loc ="lower right")
    plt.show()

    plot_length = len(test_data)
    plt.title('Test')
    plt.plot(test_data)
    plt.plot(predicted_test_df)
    plt.legend(["Real Value", "Predicted"], loc ="lower right")
    plt.show()
```

```{python id="deyLWLmZThMJ", outputId="4d0094aa-099c-490f-aa82-281ee16bae01"}
prediction_visualization(train_df, test_df, yhat_train, yhat_test)
```

<!-- #region id="lERphf0kTist" -->
### Evaluation
<!-- #endregion -->

```{python id="BcGvcilUWEEC"}
def evaluate(metric, metric_name, true_values, predicted_values):
    print(f'{metric_name} : {metric(true_values, predicted_values)}')
```

```{python id="v4-GWghuSbnA"}
def evaluation(model_name, train_data, test_data, yhat_train, yhat_test):
    print(f'{model_name} train scores:')


    evaluate(mean_absolute_error, 'MAE', train_data['Demand'], yhat_train)
    evaluate(mean_squared_error, 'MSE', train_data['Demand'], yhat_train)

    print(f'{model_name} test scores:')


    evaluate(mean_absolute_error, 'MAE', test_data['Demand'], yhat_test)
    evaluate(mean_squared_error, 'MSE', test_data['Demand'], yhat_test)

```

```{python id="qSZwIFprTkqK", outputId="7ae94952-ec22-410a-9d26-6e05a96af6ab"}
evaluation('XGB', train_df, test_df, yhat_train, yhat_test)  # for whole data
```

<!-- #region id="_286hlGi7VWD" -->
### Feature Importance and SHAPE
<!-- #endregion -->

```{python id="osueYsNP1NB8", outputId="b3c13ee6-bd74-4470-a8c5-558df5416e28"}
xgb.plot_importance(model)
plt.show()
```

```{python id="50CEqbp75Y_i", outputId="b7288f1d-517a-4707-da22-ad996453f161"}
dtrain_reg = xgb.DMatrix(train_df[feature_list].values, train_df['Demand'].values, enable_categorical=True)

explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(dtrain_reg)
shap.summary_plot(shap_values, train_df[feature_list])
```
